package week11.climbingStairs;

/* ================================================================
 *
 * Problem  : Climbing Stairs
 * Author   : 최승아
 * Date     : 2025-06-26
 *
 * ================================================================
 * 📌 문제 분석 요약
 *  한번에 두칸 또는 한칸씩 계단을 오를 수 있다. 이 때 정상에 오를 수 있는 경우의 수는 어떻게 되는가?
 *
 * 💻 알고리즘 설계
 * 1. 변수 의미 정하기
 *    dp[i]: 현재 위치까지 올 수 있는 경우의 수
 * 2. 초기 조건 설정
 *    길이가 1이거나 2일 때는 바로 값을 반환
 *    배열은 1~n까지 채우기에 n+1의 크기로 초기화
 *    1,2번째는 정해져있기 때문에 값을 채워둠
 * 3. 반복문으로 dp 테이블 채우기
 *    3부터 배열 끝까지 돌면서 반복
 *    dp[i]=dp[i-1]+dp[i-2]
 * 4. 정답 리턴
 *    dp[n]
 *
 * ⏰ 시간복잡도
 *  O(n)
 * ================================================================
 */
class Wina {
	
	
	public int climbStairs(int n) {
//		문제를 정의하고, 변수 의미 정하기
		if (n == 1) {
			return 1;
		}
		if (n == 2) {
			return 2;
		}

//		점화식(상태 전이식) 세우기
		int[] dp = new int[n + 1];

//		초기조건(base case) 설정
		dp[1] = 1;
		dp[2] = 2;

//		반복문으로 dp 테이블 채우기
		for (int i = 3; i <= n; i++) {
			dp[i] = dp[i - 1] + dp[i - 2];
		}
//		정답 리턴
		return dp[n];
	}
}
